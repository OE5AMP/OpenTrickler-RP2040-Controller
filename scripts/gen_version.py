import argparse
import logging
import subprocess
import sys
import re
import os


GIT_VERSION_COMMAND = ["git", "describe", "--tags", "--long", "--dirty", "--always"]

GIT_VERSION_PATTERN_REGEX = r'v(?P<major>\d+)\.(?P<minor>\d+)-(?P<patch>\d+)-g(?P<short_hash>[a-f0-9]+)(?P<dirty>-dirty)?'

C_HEADER_TEMPLATE = """// ---------------------------------------------------------- //
// This file is autogenerated by gen_version.py; do not edit! //
// ---------------------------------------------------------- //

#ifndef {capitalized_filename}_H_
#define {capitalized_filename}_H_

#include <stdbool.h>

// Implemented in version.c
extern const char * version_string;
extern const char * vcs_hash;
extern const bool is_dirty;

#endif  //  {capitalized_filename}_H_
"""

C_SOURCE_TEMPLATE = """// ---------------------------------------------------------- //
// This file is autogenerated by gen_version.py; do not edit! //
// ---------------------------------------------------------- //

#include "version.h"

const char * version_string = "{version_string}";
const char * vcs_hash = "{hash_string}";
const bool is_dirty = {is_dirty};
"""


def main(output_path):
    output = subprocess.check_output(GIT_VERSION_COMMAND, text=True)
    logging.debug(f'Raw output: {output}')
    match = re.match(GIT_VERSION_PATTERN_REGEX, output)

    version_string = "unknown"
    hash_string = ""
    is_dirty = False

    if match:
        groupdict = match.groupdict()

        major = groupdict['major']
        minor = groupdict['minor']
        patch = groupdict['patch']
        short_hash = groupdict['short_hash']
        dirty = groupdict['dirty']

        version_string = f"{major}.{minor}.{patch}"
        hash_string = short_hash
        is_dirty = dirty is not None

    c_header_string = C_HEADER_TEMPLATE.format(
        capitalized_filename="VERSION")
    c_source_string = C_SOURCE_TEMPLATE.format(
        capitalized_filename="VERSION", version_string=version_string, hash_string=hash_string, is_dirty={True: "true", False: "false"}[is_dirty])
    
    c_header_filepath = os.path.join(output_path, "version.h")
    with open(c_header_filepath, "w") as fp:
        fp.write(c_header_string)

    c_source_filepath = os.path.join(output_path, "version.c")
    with open(c_source_filepath, "w") as fp:
        fp.write(c_source_string)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument('-o', '--output_filepath', help="The output filepath that the C header will be written to", required=True)
    parser.add_argument('--no-minify', help="Do not minify the input file", default=False, action='store_true')

    parser.add_argument('-v', '--verbose', action='count', default=0)
    

    args = parser.parse_args()

    logging_levels = {0: logging.ERROR,
                      1: logging.DEBUG,
                      2: logging.INFO,
                      3: logging.WARNING,
                      4: logging.ERROR,
                      5: logging.CRITICAL}
    
    logging.basicConfig(stream=sys.stdout, level=logging_levels[args.verbose])

    main(args.output_filepath)
